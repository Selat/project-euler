(defconstant &maxn& 105000)
(defvar *primes* (make-array &maxn& :element-type 'fixnum))
(defvar *primes-sum* (make-array &maxn& :element-type 'fixnum))

(defun fill-primes (n)
  (declare (optimize (speed 3) (safety 0))
           (type fixnum n)
           (type (simple-array fixnum) *primes*))
  (let ((used (make-array (1+ (ceiling n 2)) :element-type 'bit :initial-element 0))
        (cur-prime-id 0)
        (cur-primes-sum 2))
    (setf (aref *primes* 0) 2)
    (setf (aref *primes-sum* 0) 2)
    (loop for i from 1 below (ceiling n 2)
          for num = (1+ (* 2 i))
          do (when (= (aref used i) 0)
               (incf cur-primes-sum num)
               (setf (aref *primes-sum* (incf cur-prime-id)) cur-primes-sum)
               (setf (aref *primes* cur-prime-id) num)
               (loop for j from num to n by num
                     for id = (floor j 2)
                     do (when (= (mod j 2) 1) (setf (aref used id) 1)))))))

(defun get-prime-id (n)
  (declare (optimize (speed 3) (safety 0))
           (type fixnum n)
           (type (simple-array fixnum) *primes*))
  (labels ((get-id (l r)
             (declare (type unsigned-byte l)
                      (type unsigned-byte r))
             (if (>= l r) l
                 (let ((m (ceiling (+ l r) 2)))
                   (if (< n (aref *primes* m))
                       (get-id l (1- m))
                       (get-id m r))))))
    (get-id 0 (1- &maxn&))))

(defun solve (n)
  (declare (optimize (speed 3) (safety 0))
           (type fixnum n)
           (type (simple-array fixnum) *primes-sum*))
  (if (< n 2) 0
      (aref *primes-sum* (get-prime-id n))))

(fill-primes (* &maxn& 10))

(loop repeat (read)
      do (format t "~A~%" (solve (read))))
