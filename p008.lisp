(defun solve (n k a)
  (declare (optimize (speed 3) (safety 0))
           (type fixnum k)
           (type (simple-array fixnum) a))
  (let ((res 0)
        (cur 1)
        (last-zero-id -1))
    (setf cur res)
    (loop for i from 0 below n
          for c = (aref a i)
          do (if (zerop c) (setf last-zero-id i)
                 (cond ((= last-zero-id (1- i))
                        (setf cur c)
                        (if (and (= k 1) (< res cur)) (setf res cur)))
                       ((<= (- i last-zero-id) k)
                        (setf cur (* cur c))
                        (if (and (= (- i last-zero-id) k) (< res cur)) (setf res cur)))
                       (t (setf cur (/ cur (aref a (- i k))))
                          (setf cur (* cur (aref a i)))
                          (if (< res cur) (setf res cur))))))
    res))

(defun read-vec ()
 (declare (optimize (speed 3) (safety 0)))
  (let* ((s (read-line))
         (res (make-array (length s) :element-type 'fixnum)))
    (loop for i from 0 below (length s)
          do (setf (aref res i) (parse-integer (string (aref s i)))))
    res))

(loop repeat (read) do
      (format t "~A~%" (solve (read) (read) (read-vec))))
